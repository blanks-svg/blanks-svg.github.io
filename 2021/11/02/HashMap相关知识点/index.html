<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        Hexo
    </title>
    <meta name="description" content=  >
    <meta name="keywords" content= Blog,Code >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            HashMap相关知识点
        </p>
        <hr>
    </div>
    <div class="post-content">
        <p>先看看hashMap在JDK1.8的结构，如下图，用的是数组+链表+红黑树的结构，也叫哈希桶，在JDK1.8之前都是数组+链表的结构，因为在链表的查询操作都是O(N)的时间复杂度，而且hashMap中查询操作也是占了很大比例的，如果当节点数量多，转换为红黑树结构，那么将会提高很大的效率，因为红黑树结构中，增删改查都是O(log n)。</p>
<h3 id="JDK1-8-HashMap数据结构图"><a href="#JDK1-8-HashMap数据结构图" class="headerlink" title="JDK1.8 HashMap数据结构图"></a>JDK1.8 HashMap数据结构图</h3><p><img src="https://i.loli.net/2021/11/02/VYqtE9izmNKkOT3.jpg" alt="0bd617d78eb7474f3ff0f42d4887f16a.png"></p>
<h3 id="HashMap数据插入原理"><a href="#HashMap数据插入原理" class="headerlink" title="HashMap数据插入原理"></a>HashMap数据插入原理</h3> <img src="https://i.loli.net/2021/11/02/nuTLPfrKSBOWZ47.jpg" alt="af26da061524b4f0a182cf0b2749e1ce.png"  />

<ul>
<li>判断数组是否为空，为空进行初始化;</li>
<li>不为空，计算 k 的 hash 值，通过 (n - 1) &amp; hash计算应当存放在数组中的下标 index ;</li>
<li>查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；</li>
<li>存在数据，说明发生了hash冲突, 继续判断key是否相等，相等，用新的value替换原数据(onlyIfAbsent为false)；</li>
<li>如果不相等，判断当前节点类型是不是树型节点，如果是树型节点，创建树型节点插入红黑树中；</li>
<li>如果不是树型节点，创建普通Node加入链表中；判断链表长度是否大于 8， 大于的话链表转换为红黑树；</li>
<li>插入完成之后判断当前节点数是否大于阈值，如果大于开始扩容为原数组的二倍</li>
</ul>
<h3 id="HashMap如何设定初始容量大小"><a href="#HashMap如何设定初始容量大小" class="headerlink" title="HashMap如何设定初始容量大小"></a>HashMap如何设定初始容量大小</h3><p>一般如果new HashMap() 不传值，默认大小是16，负载因子是0.75， 如果自己传入初始大小k，初始化大小为 大于k的 2的整数次方，例如如果传10，大小为16。</p>
<h3 id="HashMap的哈希函数如何设计的"><a href="#HashMap的哈希函数如何设计的" class="headerlink" title="HashMap的哈希函数如何设计的"></a>HashMap的哈希函数如何设计的</h3><p>大家都知道上面代码里的key.hashCode()函数调用的是key键值类型自带的哈希函数，返回int型散列值。</p>
<p>理论上散列值是一个int型，如果直接拿散列值作为下标访问HashMap主数组的话，考虑到2进制32位带符号的int表值范围从**-2147483648<strong>到</strong>2147483648**。前后加起来大概40亿的映射空间。只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。</p>
<p>但问题是一个40亿长度的数组，内存是放不下的。你想，HashMap扩容之前的数组初始大小才16。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来访问数组下标。源码中模运算是在这个indexFor( )函数里完成的。</p>
<p>indexFor的代码也很简单，就是把散列值和数组长度做一个”与”操作，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便说一下，这也正好解释了为什么HashMap的数组长度要取2的整数幂。因为这样（数组长度-1）正好相当于一个“低位掩码”。“与”操作的结果就是散列值的高位全部归零，只保留低位值，用来做数组下标访问。以初始长度16为例，16-1=15。2进制表示是00000000 00000000 00001111。和某散列值做“与”操作如下，结果就是截取了最低的四位值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    10100101 11000100 00100101</span><br><span class="line">&amp;   00000000 00000000 00001111</span><br><span class="line">----------------------------------</span><br><span class="line">    00000000 00000000 00000101    //高位全部归零，只保留末四位</span><br></pre></td></tr></table></figure>

<p>但这时候问题就来了，这样就算我的散列值分布再松散，要是只取最后几位的话，碰撞也会很严重。更要命的是如果散列本身做得不好，分布上成等差数列的漏洞，恰好使最后几个低位呈现规律性重复，就无比蛋疼。</p>
<p>时候“扰动函数”的价值就体现出来了，说到这里大家应该猜出来了。看下面这个图</p>
<img src="https://i.loli.net/2021/11/02/HTyzFwne3juQBgG.jpg" alt="img"  />

<p>另外Java1.8相比1.7做了调整，1.7做了四次移位和四次异或，但明显Java 8觉得扰动做一次就够了，做4次的话，多了可能边际效用也不大，所谓为了效率考虑就改成一次了。</p>
<p>如果你还不明白的话</p>
<p>看下图，左边两组是数组长度为16（2的4次方），右边两组是数组长度为15。两组的hashcode均为8和9，但是很明显，当它们和1110“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8和9会被放到同一个链表上，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为15的时候，hashcode的值会与14（1110）进行”与”，那么最后一位永远是0，而0001，0011，0101，1001，1011，0111，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！ </p>
<p><img src="https://i.loli.net/2021/11/02/WBRkjwohb2KpuvY.jpg" alt="img"></p>
<h3 id="JDK1-8-的其他优化及原因"><a href="#JDK1-8-的其他优化及原因" class="headerlink" title="JDK1.8 的其他优化及原因"></a>JDK1.8 的其他优化及原因</h3><ul>
<li>数组+链表改成了数组+链表或红黑树；</li>
<li>链表的插入方式从头插法改成了尾插法，简单说就是插入时，如果数组位置上已经有元素，1.7将新元素放到数组中，原始节点作为新节点的后继节点，1.8遍历链表，将元素放置到链表的最后；</li>
<li>扩容的时候1.7需要对原数组中的元素进行重新hash定位在新数组的位置，1.8采用更简单的判断逻辑，位置不变或索引+旧容量大小；</li>
<li>在插入时，1.7先判断是否需要扩容，再插入，1.8先进行插入，插入完成再判断是否需要扩容</li>
</ul>
<p><strong>为什么要做这些优化？</strong></p>
<ul>
<li>防止发生hash冲突，链表长度过长，将时间复杂度由O(n)降为O(logn);</li>
<li>因为1.7头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；</li>
</ul>
<h3 id="JDK1-7-HashMap链表成环问题"><a href="#JDK1-7-HashMap链表成环问题" class="headerlink" title="JDK1.7 HashMap链表成环问题"></a>JDK1.7 HashMap链表成环问题</h3><p>A线程在插入节点B，B线程也在插入，遇到容量不够开始扩容，重新hash，放置元素，采用头插法，后遍历到的B节点放入了头部，这样形成了环，如下图所示：</p>
<p><img src="https://i.loli.net/2021/11/02/qzVO24JTQLYxniP.jpg" alt="bc3fb7a9a3147a7aa4e3dd256fac278d.png"></p>
<p><strong>扩容的时候为什么1.8 不用重新hash就可以直接定位原节点在新数据的位置呢?</strong></p>
<p>这是由于扩容是扩大为原数组大小的2倍，用于计算数组位置的掩码仅仅只是高位多了一个1，举个例子：</p>
<p>扩容前长度为16，用于计算 (n-1) &amp; hash 的二进制n - 1为0000 1111，</p>
<p>扩容后为32后的二进制就高位多了1，====&gt;为0001 1111。</p>
<p>因为是&amp; 运算，1和任何数 &amp; 都是它本身，那就分二种情况，如下图：原数据hashcode高位第4位为0和高位为1的情况；</p>
<p>第四位高位为0，重新hash数值不变，第四位为1，重新hash数值比原来大16(旧数组的容量)</p>
<p><img src="https://i.loli.net/2021/11/02/gZGuqvLVnU6NWFf.jpg" alt="47ed92e957ab342d3f10b8803ee02897.png"></p>
<h3 id="HashMap是线程安全的吗？"><a href="#HashMap是线程安全的吗？" class="headerlink" title="HashMap是线程安全的吗？"></a>HashMap是线程安全的吗？</h3><p>不是，在多线程环境下，1.7 会产生死循环、数据丢失、数据覆盖的问题，1.8 中会有数据覆盖的问题。</p>
<p>以1.8为例，当A线程执行判断index位置为空后正好挂起，B线程开始执行，往index位置的写入节点数据，这时A线程恢复线程，执行赋值操作，就把A线程的数据给覆盖了；</p>
<p>另外有时也会造成多线程同时扩容等问题</p>
<h3 id="如何解决这个线程不安全的问题？"><a href="#如何解决这个线程不安全的问题？" class="headerlink" title="如何解决这个线程不安全的问题？"></a>如何解决这个线程不安全的问题？</h3><p>Java中有HashTable、以及ConcurrentHashMap可以实现线程安全的Map</p>
<ul>
<li><p>HashTable是直接在操作方法上加synchronized关键字，锁住整个数组，粒度比较大；</p>
</li>
<li><p>ConcurrentHashMap使用分段锁，降低了锁粒度，让并发度大大提高。</p>
</li>
</ul>
<h3 id="ConcurrentHashMap的分段锁的实现原理"><a href="#ConcurrentHashMap的分段锁的实现原理" class="headerlink" title="ConcurrentHashMap的分段锁的实现原理"></a>ConcurrentHashMap的分段锁的实现原理</h3><p>ConcurrentHashMap成员变量使用volatile 修饰，免除了指令重排序，同时保证内存可见性，另外使用CAS操作和synchronized结合实现赋值操作，在JDK1.7以前采用的是分段锁，JDK1.8以后降低了锁的粒度，只会锁住当前操作的节点</p>
<p>如下图，线程A锁住A节点所在链表，线程B锁住B节点所在链表，操作互不干涉。</p>
<img src="https://i.loli.net/2021/11/02/fXPy5RkQCSUEsGi.jpg" alt="43df58f7aeebfba5b482663c10744c8f.png" style="zoom:80%;" />





<h3 id="链表转红黑树是链表长度达到阈值，这个阈值是多少？"><a href="#链表转红黑树是链表长度达到阈值，这个阈值是多少？" class="headerlink" title="链表转红黑树是链表长度达到阈值，这个阈值是多少？"></a>链表转红黑树是链表长度达到阈值，这个阈值是多少？</h3><p>阈值是8，红黑树转链表阈值为6，因为经过计算，在hash函数设计合理的情况下，发生hash碰撞8次的几率为百万分之6，概率说话。。因为8够用了，至于为什么转回来是6，因为如果hash碰撞次数在8附近徘徊，会一直发生链表和红黑树的转化，为了预防这种情况的发生。</p>
<h3 id="HashMap内部节点是有序的吗？"><a href="#HashMap内部节点是有序的吗？" class="headerlink" title="HashMap内部节点是有序的吗？"></a>HashMap内部节点是有序的吗？</h3><p>是无序的，根据hash值随机插入，有序的Map有LinkedHashMap 和 TreeMap</p>
<p> LinkedHashMap内部维护了一个单链表，有头尾节点，同时LinkedHashMap节点Entry内部除了继承HashMap的Node属性，还有before 和 after用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序。</p>
<p>TreeMap是按照Key的自然顺序或者Comprator的顺序进行排序，内部是通过红黑树来实现。</p>

    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: Blanks | Theme By <a class="theme-author" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">Page Views: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">Unique Visitors: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="">
<input type="hidden" id="valine_appKey" value="">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
